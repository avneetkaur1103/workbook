Most providers of message-oriented middleware have adopted the enterprise service bus concept as de facto standard for a service-oriented architecture. The implementations of ESB use event-driven and standards-based message-oriented middleware in combination with message queues as technology frameworks.

The primary duties of an ESB are:

Route messages between services
Monitor and control routing of message exchange between services
Resolve contention between communicating service components
Control deployment and versioning of services
Marshal use of redundant services
Provide commodity services like event handling, data transformation and mapping, message and event queuing and sequencing, security or exception handling, protocol conversion and enforcing proper quality of communication service

Ideally, the ESB should be able to replace all direct contact with the applications on the bus, so that all communication takes place via the ESB. To achieve this objective, the ESB must encapsulate the functionality offered by its component applications in a meaningful way. This typically occurs through the use of an enterprise message model. The message model defines a standard set of messages that the ESB transmits and receives. When the ESB receives a message, it routes the message to the appropriate application.
The beauty of the ESB lies in its platform-agnostic nature and the ability to integrate with anything at any condition. - Infinite Scalability
# -------------------------------------------------
Why LB + MUX?
LB is really dumb, unable to route messages
MUX is able to route messages to the right 1A service
If we remove the MUXes, the LBs will not know which 1A service to target.
If we remove the LBs, then the clients will either:
have to load balance between each MUX => expose 1A architecture to client. What if we want to add a new MUX? => cannot scale in terms of connections
Have to target always the same MUX => too much load on a single MUX. What if it crashes? => client cannot reach 1A

Why MUX + SRV?
SRVs can store sessions, MUXes cannot
If we remove SRVs then:
The MUXes will have to store the sessions
The LBs will forward the client queries to a random MUX
The client queries will likely not land on a MUX that has their session
The MUX is smart enough to figure out which SRV has the session

MUXs and SRVs are both mere computers where we run some C++ processes.

LBs are not managed by the SI and not a part of the SI.

#---------------------------------------------------
The SI is scalable but not fully resilient
Configuration is static: Every components is statically named in the platform
Full mesh: Components are all connected with each others

What are peak tokens?

#----------------------------------------------------
The simplest form of the Service Integrator is composed of multiple Multiplexers
Onto which Acceptors connectors are defined to receive incoming traffic
Requestors connectors are defined to connect to OTF backend application Or to connect to external systems

The Multiplexer works at transport level, it can don: receive message in HTTP and forward it in ERPLv5
However, it doesn’t transform messages or manage session data, it doesn’t hold any state

#----------------------------------------------------
Service Access Point (SAP)
Logical name identifying an Amadeus entry point 

Part of the message
Session Destination/UNTO field in queries
Session Origin/FROM field in replies

Two main SAP types
Routing SAP: All messages on this SAP go to the same application
Integration SAP: The messages go to various applications depending on the requested service.

How many RSAPs:- At least:
One RSAP per BE to BE link
One generic RSAP per BE
One generic RSAP per remote system

# ---------------------------------------------------
Routing SAP, “RSAP”
Is located on multiplexers (MUX) only
Does not create/store any session/context
Load balances traffic between each application node
Main uses: Internal traffic (BE to BE), outbound traffic towards external provider

# ----------------------------------------------------
Integration SAP, “ISAP”
Handles established sessions
Handles services (and not only messages)
Targets different applications, thanks to a routing table
Are located on servers
Are known by multiplexers
Have a service publication table

How many ISAP do we have?
One ISAP per interface per customer
Generic SAP for some interfaces

Hosts the Distributed ConteXt “DCX”
The DCX embeds context information in real traffic in order to let applications retrieve the information needed to process their use cases:
1. Middleware part containing routing affinity tokens for each application, SAP properties etc. This part is built by the Service Integrator.
2. Security part containing system/user identification, and security definitions.
3. Application part containing the hierarchy of Ids pointing to applicative contexts. 
4. Transaction part containing information valid for the current transaction only (removed then by the SI). 

# ----------------------------------------------------
5 SI Environment
SI-DEV for DEV and DES
SI-PDT for MIG/UAT/INT/FRT/SKL/BT0PRD, and… PDT
SI-PPT for PPT
SI-PRD for PRD
SI-RED for disaster recovery

Farm:
1. A farm implements a subset of the total SI configuration, dedicated to a specific type of traffic
2. A single SAP can be published on one farm and one farm only
3. There are currently 9 farms:
	Altea for internal traffic
	TN for cryptic traffic
	GUI for DCS traffic
	Host-to-Host for traffic towards external legacy providers
	Web Services for Web Services and APIv2 traffic
	Web Services for Airlines
	DMZ for traffic from the Internet
	PRP and CIF (outbound)
4. Everything is handled by a single Master Agent

#-------------------------------------------------------
Unique correlation ID for each new conversation.
Unique carf ID for each new session.
Application -|Exposes|- services -|published on| - SAPs
The Multiplexer works at transport level, it can do protocol translation: receive message in HTTP and forward it in ERPLv5

MAG:
In order to configure the platform components, an operator uses the Master Agent
The Master Agent detects the changes made by the operator to the configuration and dispatch Configuration Events to nodes affected by this changes.



