n-th catalan number.
   T(n) = (2n)! / (n+1)!n! => [0,n-1]sum(T(i)*T(n-i-1))

Masters Theorem:
https://www.geeksforgeeks.org/analysis-algorithm-set-4-master-method-solving-recurrences/
T(n) = aT(n/b) + f(n) |Where b>1 and a>=1
There are following three cases:
1. If f(n) = Θ(n^c) where c < Log(b)a then T(n) = Θ(n^Log(b)a)
2. If f(n) = Θ(n^c) where c = Log(b)a then T(n) = Θ(n^c*Log n)
3.If f(n) = Θ(n^c) where c > Log(b)a then T(n) = Θ(f(n))

It is not possible to construct a general Binary Tree from preorder and postorder traversals.

Minimum number of swaps required to sort an array => Swap position graph can be visualized as many non intersection swap circle.

From inorder & postorder to tree => reverse-preoder(postorder) order is taken as guide (left-right-root) & in-order is used in partition & return left & right sets(unorder, guides by postorder to place values in right place)

From inorder & levelorder to tree => level order is taken as structure guide(root- left - right ) & in-order is used in partition & return left & right sets(unorder, guides by intersection(levelorder,left subset){only the levels in left} and intersection(levelorder,right subset){only the levels in right} to place values in right place)[Unclear]

Given an arbitrary binary tree, convert it to a binary tree that holds Children Sum Property:
if diff is 0 then nothing needs to be done.
If diff > 0 ( node’s data is smaller than node’s children sum) increment the node’s data by diff.
If diff < 0 (node’s data is greater than the node's children sum) then increment one child’s data.